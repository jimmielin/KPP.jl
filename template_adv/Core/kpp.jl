# Initialize the reaction network
using DiffEqBase: AbstractReactionNetwork

"""
    jlkpp_Initialize_Defaults(Array{Float64, 1})
Given an array of species concentrations fill background concentrations derived
from the original KPP specification file and imported into the registry
into the given array, by grid box
"""
function jlkpp_Initialize_Defaults(u::AbstractArray{Float64, 1})
    @inbounds for spc in 1:length(jlkpp_bg_ic)
        u[spc] = jlkpp_bg_ic[spc]
    end
end

"""
    jlkpp_SUN(t)
Given time return the current sun light using local time (in seconds)
Based off Rates.F90 generated by KPP (Damien et al., 2002)
"""
function jlkpp_SUN(t::Float64)
    sunrise = 4.5
    sunset  = 19.5
    thour   = t/3600.0 % 24
    # the below line serves unknown purpose in the original FORTRAN code
    # tfrac   = thour - (unsafe_trunc(Int64, thour)/24) # "Tlocal" in KPP, misleading name
    if(thour >= sunrise && thour <= sunset)
        ttmp = (2.0*thour - sunrise - sunset)/(sunset - sunrise)
        ttmp = abs(ttmp) * ttmp # preserve sign
        (1.0 + cos(Ï€ * ttmp))/2.0
    else
        0.0
    end
end

"""
    jlkpp_Compile(rs, u_scratch)
Runs an iteration of the solver to "pre-compile" the ODE solver.
This is necessary because otherwise one encounters exorbitantly high first-timestep
compute times and we don't want to benchmark the JIT, we want the numerical compute
performance.
"""
function jlkpp_Compile(rs::AbstractReactionNetwork, u_scratch::AbstractArray{Float64, 1})
    println("KPP.jl: Running ODE solver for type specialization")
    @time oprob = ODEProblem(rs, u_scratch, (0.0, 600.0), (0, 300.0, 2.4476e13))
    @time solve(oprob, alg_hints=[:stiff], dense=false, save_on=false, calck=false)
    println("KPP.jl: Finished")
end


"""
    jlkpp_Timestep(rs, u, t, dt, t_chm)
Given a constructed `AbstractReactionNetwork` with added ODEs,
current conditions u constructed by `species`, current time, timestep,
parameters are built and one timestep of the integrator is run.

This construction is fairly efficient based on documentation from
https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/41
"""
function jlkpp_Timestep(;
    rs::AbstractReactionNetwork,
    u::AbstractArray{Float64, 1},
    t::Float64, dt::Float64,
    t_chm::Float64
) # where RN <: AbstractReactionNetwork
    # $TIMESTEP_PARAM$ #
    #         SUN
    # p     = (jlkpp_SUN(t))
    # At some time we might want to use Callback functions to update parameters:
    # http://docs.juliadiffeq.org/latest/features/callback_functions.html#ContinuousCallbacks-1


    # $TIMESTEP_AFTER_PARAM$
    oprob = ODEProblem(rs, u, (0.0, dt), p)
    solve(oprob, alg_hints=[:stiff], dense=false, save_on=false, calck=false,
          reltol=1.0e-4, abstol=1.0e-3) # alg_hints=[:stiff]
end


"""
    jlkpp_Init(rs)
Initialize the chemical mechanism by returning a `KppReactionNetwork`
This function is imported in bulk by the Kpp code generator.
"""
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ! DO NOT EDIT BELOW MANUALLY
# ! This file is automatically generated by KPP.jl
# ! Do make modifications to the chemical mechanism, use KPP.jl to generate
# ! the registry, state generator and kpp mechanism callers
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# $MECHANISM$ #
