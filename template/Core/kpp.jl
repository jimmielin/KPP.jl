# $EXTRA_LIBS_KPP$ #

include("kpp_rates.jl")

"""
    jlkpp_Initialize_Defaults(Array{Float64, 1})
Given an array of species concentrations fill background concentrations derived
from the original KPP specification file and imported into the registry
into the given array, by grid box
"""
function jlkpp_Initialize_Defaults(u::Array{Float64, 1})
    @inbounds for spc in 1:jlkpp_nspecies
        u[spc] = jlkpp_bg_ic[spc]
    end
end

"""
    jlkpp_SUN(t)
Given time return the current sun light using local time (in seconds)
Based off Rates.F90 generated by KPP (Damien et al., 2002)
"""
function jlkpp_SUN(t)
    sunrise = 4.5
    sunset  = 19.5
    thour   = t/3600.0 % 24
    # the below line serves unknown purpose in the original FORTRAN code
    # tfrac   = thour - (unsafe_trunc(Int64, thour)/24) # "Tlocal" in KPP, misleading name
    if(thour >= sunrise && thour <= sunset)
        ttmp = (2.0*thour - sunrise - sunset)/(sunset - sunrise)
        ttmp = abs(ttmp) * ttmp # preserve sign
        (1.0 + cos(Ï€ * ttmp))/2.0
    else
        0.0
    end
end

"""
    jlkpp_Compile(rs, u_scratch, tstart, tend)
Runs an iteration of the solver to "pre-compile" the ODE solver.
This is necessary because otherwise one encounters exorbitantly high first-timestep
compute times and we don't want to benchmark the JIT, we want the numerical compute
performance.
"""
# $KPP_COMPILE$ #


"""
    jlkpp_Timestep(u, ODEProblem, t, dt, t_chm)
Given a constructed `AbstractReactionNetwork` or ODEProblem with added ODEs,
current conditions u constructed by `species`, current time, timestep,
parameters are built and one timestep of the integrator is run.

This is a mutating form where u is updated inplace in the function.

This construction is fairly efficient based on documentation from
https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/41
"""
function jlkpp_Timestep!(
    u::Array{Float64, 1},
    oprob::ODEProblem,
    t::Float64, dt::Float64,
    T_chm::Float64
) # where RN <: AbstractReactionNetwork
    # $TIMESTEP_PARAM$ #
    # Lambda parameters:
    #              SUN
    # p     = t-> (jlkpp_SUN(t))
    # At some time we might want to use Callback functions to update parameters:
    # http://docs.juliadiffeq.org/latest/features/callback_functions.html#ContinuousCallbacks-1


    # $TIMESTEP_AFTER_PARAM$ #
    # oprob = ODEProblem(rs, u, (0.0, dt), p)

    # Rebuild the ODE problem
    # remove @time after done debugging
    _oprob = remake(oprob; u0=u, tspan=(t, t+dt), p=p)
    _osol  = solve(_oprob, CVODE_BDF(), save_everystep=false,# dense=false, save_on=false, calck=false,
          reltol=1.0e-4, abstol=1.0e-3) # alg_hints=[:stiff]

    # $TIMESTEP_AFTER_SOLVE$ #

    # Update species concentrations as this is the mutating form.
    # Allow hooks
    for spc in 1:jlkpp_nspecies
        # $TIMESTEP_SPC_LOOP_COND_LEFT$ #
        u[spc] = _osol.u[end][spc]
        # $TIMESTEP_SPC_LOOP_COND_RIGHT$ #
    end
end

# $KPP_CODE_EXTRA$ #

# Initialize the chemical mechanism by returning a `KppReactionNetwork`
# This function is imported in bulk by the Kpp code generator.

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ! DO NOT EDIT BELOW MANUALLY
# ! This file is automatically generated by KPP.jl
# ! Do make modifications to the chemical mechanism, use KPP.jl to generate
# ! the registry, state generator and kpp mechanism callers
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# $MECHANISM$ #
